<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>PSR&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="动态规划序列比对 两序列比对 动态规划将一个问题，拆分成一个个子问题，直到子问题可以直接解决。然后，把子问题的答案保存起来，以减少重复计算，再根据子问题答案反推，得出原问题解的一种方法![[Pasted image 20231221151920.png]] 寻求两序列间距离的最小即最短距离 在给定计分规则的情况下，数学上可证明能给出具有最高比对打分的对比矩阵。 动态规划进行序列比对的基本思想 在(">
<meta property="og:type" content="article">
<meta property="og:title" content="PSR&#39;s Blog">
<meta property="og:url" content="http://psrpsr23.github.io/blog/2024/04/28/note/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8E%9F%E7%90%86/%E6%80%BB%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="PSR&#39;s Blog">
<meta property="og:description" content="动态规划序列比对 两序列比对 动态规划将一个问题，拆分成一个个子问题，直到子问题可以直接解决。然后，把子问题的答案保存起来，以减少重复计算，再根据子问题答案反推，得出原问题解的一种方法![[Pasted image 20231221151920.png]] 寻求两序列间距离的最小即最短距离 在给定计分规则的情况下，数学上可证明能给出具有最高比对打分的对比矩阵。 动态规划进行序列比对的基本思想 在(">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-28T08:12:22.010Z">
<meta property="article:modified_time" content="2024-01-19T00:11:15.393Z">
<meta property="article:author" content="彭澍荣# 博客的作者">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="PSR's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/blog/favicon.png">
  
  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
    
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">PSR&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">Come on!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/blog/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://psrpsr23.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-note/大三上/生物信息学原理/总复习——原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/04/28/note/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8E%9F%E7%90%86/%E6%80%BB%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2024-04-28T08:12:22.010Z" itemprop="datePublished">2024-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="序列比对"><a href="#序列比对" class="headerlink" title="序列比对"></a>序列比对</h3><ul>
<li>两序列比对<ul>
<li>动态规划<code>将一个问题，拆分成一个个子问题，直到子问题可以直接解决。然后，把子问题的答案保存起来，以减少重复计算，再根据子问题答案反推，得出原问题解的一种方法</code>![[Pasted image 20231221151920.png]]</li>
<li>寻求两序列间距离的最小即最短距离</li>
<li>在给定计分规则的情况下，数学上可证明能给出具有最高比对打分的对比矩阵。</li>
<li>动态规划进行序列比对的基本思想<ul>
<li>在(i,j)处的最佳排列是在(i,j)之前最佳排列加上i和j的最佳排列</li>
<li>重复过程直到两个序列的终点</li>
</ul>
</li>
</ul>
</li>
<li>Smith-Waterman算法<ul>
<li>比较的时候加入0</li>
<li>附初始值为零</li>
<li>从最大值回溯到0</li>
</ul>
</li>
<li>Semi-Global Alignment(半全局比对)<ul>
<li>只第一列初始化为0</li>
<li>最后一列的最大值开始回溯</li>
</ul>
</li>
<li>BLAST算法<ul>
<li>对于待比对或检索的序列，建立词列表或哈希表</li>
<li>确定搜索目标数据库中所有包含与上述词列表中词完全一样的序列（hit）</li>
<li>对上述的每一条序列中，在匹配区域（hit）向两端以动态规划算法向外延伸，扩展对比区域；得到高得分联配对（HSP）</li>
</ul>
</li>
<li>多序列比对<ul>
<li>SP得分![[Pasted image 20240118114320.png]]</li>
<li>精确算法</li>
<li>优化算法<ul>
<li>剪枝技术<ul>
<li>将搜索空间限定在一个较小的区域范围内</li>
</ul>
</li>
<li>Carrillo-Lipman方法<ul>
<li>先进行双序列比对</li>
</ul>
</li>
</ul>
</li>
<li>近似算法<ul>
<li>星形比对<ul>
<li>在给定的若干序列中，选择一个核心序列，通过该序列与其它序列的两两比对形成所有序列的多重比对a，从而使得a在核心序列和任何一个其它序列方向的投影是最优的两两比对。$$\sum sim(s_{i},s_{c})$$</li>
</ul>
</li>
<li>树形比对<ul>
<li>将序列赋予树的内部节点，可以计算树中每个分支的权值</li>
<li>权值代表对应分支连接的两个序列之间的相似性</li>
<li>所有权值的和就是这棵树的得分</li>
</ul>
</li>
<li>渐进式比对<ul>
<li>将序列多重比对转化为两两比对，逐渐将两两比对结合起来，形成完整的多序列比对。</li>
<li>先将多个序列进行两两比对，基于这些比较，计算得到一个距离矩阵，该矩阵反映每对序列的关系</li>
<li>利用距离矩阵，建立一棵“相关树（指导树）”</li>
<li>从最接近的一对序列出发，逐步归并形成比对的聚类，直到所有序列处理完。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h3><ul>
<li>一个隐马尔可夫模型 (HMM) 是一个五元组：(ΩX, ΩO, A, B, π)<ul>
<li>状态集 ΩX &#x3D; {q1,…,qN}：状态的有限集合</li>
<li>观测集 ΩO &#x3D; {v1,…,vM}：观察值的有限集合</li>
<li>转移概率矩阵 A &#x3D; {aij}， aij &#x3D; p(Xt+1 &#x3D; qj |Xt &#x3D; qi)</li>
<li>输出概率矩阵 B &#x3D; {bik}，bik &#x3D; p(Ot &#x3D; vk | Xt &#x3D; qi)</li>
<li>初始状态分布 π &#x3D; {πi}， πi &#x3D; p(X1 &#x3D; qi)</li>
</ul>
</li>
<li>三个基本问题<ul>
<li>评估问题 (Evaluation)向前算法<ul>
<li>给定模型，求某个观察值序列的概率p(σ|λ)</li>
</ul>
</li>
<li>解码问题 (Decoding)Viterbi算法<ul>
<li>对于给定模型和观察值序列，求可能性最大的状态序列</li>
<li>Bellman最优性原理： 一个过程的最优策略具有这样的性质，即无论过去状态和决策如何，对前面决策形成的状态而言，余下的策略必构成最优策略。</li>
</ul>
</li>
<li>学习问题 (Learning)向前向后算法<ul>
<li>对于给定的一个观察值序列，调整参数λ，使得观察值出现的概率p(σ|λ)最大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="概率频率相关"><a href="#概率频率相关" class="headerlink" title="概率频率相关"></a>概率频率相关</h2><h3 id="频率比值-概率比值"><a href="#频率比值-概率比值" class="headerlink" title="频率比值&#x2F;概率比值"></a>频率比值&#x2F;概率比值</h3><ul>
<li>计分矩阵<ul>
<li>序列比对过程中使用的计分规则，是序列比对的重要组成部分，他给出序列比对中碱基或氨基酸匹配或错配值，故又称替换矩阵</li>
<li>DNA替换矩阵<ul>
<li>PAM矩阵 几就是自乘几次</li>
</ul>
</li>
<li>氨基酸替换矩阵<ul>
<li>Dayhoff矩阵</li>
<li>BLOSUM替换矩阵</li>
</ul>
</li>
</ul>
</li>
<li>PSSM<ul>
<li>要构建出PSSM矩阵，首先要得到position frequency matrix (PFM)，即在每个位置的四种核苷酸出现的次数。</li>
<li>根据碱基频数分布矩阵首先计算出碱基频率分布矩阵，称之为position probability matrix (PPM)。</li>
<li>在PPM矩阵基础上，用背景序列的碱基分布频率来校正对应的值，就可以得到PWM矩阵。![[Pasted image 20240118122613.png]]</li>
<li>序列特征分析![[Pasted image 20240118122735.png]]</li>
</ul>
</li>
<li>LOD<ul>
<li>LOD值：logarithm of the odds score，<ul>
<li>LOD&#x3D;log10(L1&#x2F;L0)，L1是这个位点有QTL的概率，L0是这个位点无QTL的概率。如果LOD&#x3D;3，则意味着这个位点有QTL的概率是无QTL的概率的1000倍。</li>
</ul>
</li>
<li>LOD置信区间<ul>
<li>2-LOD置信区间就是LOD波动曲线从峰的最大值降低2的时候(Y轴), 对应在遗传图谱上跨越的区域(X轴)。2-LOD置信区间大概对应99.8%的置信区间，即功能基因有99.8%概率已经落在这个区域内了</li>
</ul>
</li>
</ul>
</li>
<li>Chou-Fasman法<ul>
<li>是一种基于单个氨基酸残基统计的经验预测方法。	通过统计分析，获得的每个残基出现于特定二级结构构象的倾向性因子，进而利用这些倾向性因子预测蛋白质的二级结构。</li>
<li>Pi &#x3D; Ai &#x2F; Ti  	(i&#x3D; ,β,c, t)【】	<ul>
<li>Ti是所有被统计残基处于构象态i的比例；</li>
<li>Ai是第A种残基处于构象态i 的比例；</li>
<li>Pi大于1.0表示该残基倾向于形成二级结构构象i，小于1.0则表示倾向于形成其它构象。</li>
</ul>
</li>
<li>蛋白质二级结构的组成规律性比较强</li>
<li>三种基本二级结构平均占氨基酸残基的85%</li>
<li>各种二级结构非均匀地分布在蛋白质中</li>
<li>每种氨基酸出现在各种二级结构中倾向或者频率是不同的</li>
<li>在序列中寻找规则二级结构的成核位点和终止位点。 </li>
<li>规则<ul>
<li>螺旋规则</li>
<li>折叠规则</li>
<li>转角规则</li>
<li>重叠规则</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="马可夫链、隐马尔科夫模型"><a href="#马可夫链、隐马尔科夫模型" class="headerlink" title="马可夫链、隐马尔科夫模型"></a>马可夫链、隐马尔科夫模型</h3><ul>
<li>具有马尔可夫性的随机序列称为马尔可夫过程 ，或称马尔可夫链。<ul>
<li>马尔可夫链的时间和状态都离散</li>
<li>一阶马尔可夫模型是最简单的马尔可夫模型，它的状态选择仅与前一个状态有关</li>
<li>n阶马尔可夫模型状态间的转移仅依赖于前n个状态的马尔科夫过程</li>
<li>马尔可夫模型(Markov Model)有时又称作可视马尔可夫模型(Visible Markov Model, VMM), 由于其每个状态代表了一个可观察的事件</li>
</ul>
</li>
<li>在马尔科夫模型的基础上，增加不可直接观察的参数（隐藏状态）</li>
</ul>
<h3 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h3><p>![[Pasted image 20240118124550.png]]</p>
<h2 id="统计-评估技术"><a href="#统计-评估技术" class="headerlink" title="统计&#x2F;评估技术"></a>统计&#x2F;评估技术</h2><h3 id="Bootstrap、permutation"><a href="#Bootstrap、permutation" class="headerlink" title="Bootstrap、permutation"></a>Bootstrap、permutation</h3><ul>
<li>Bootstrap<ul>
<li>从排列的多序列中随机有放回的抽取某一列，构成相同长度的新的排列序列</li>
<li>重复上面的过程，得到多组新的序列</li>
<li>对这些新的序列进行建树，再观察这些树与原始树是否有差异，以此评价建树的可靠性</li>
</ul>
</li>
<li>permutation ![[Pasted image 20240118125411.png]]</li>
</ul>
<h3 id="TPR、FPR、FDR、Q-value"><a href="#TPR、FPR、FDR、Q-value" class="headerlink" title="TPR、FPR、FDR、Q-value"></a>TPR、FPR、FDR、Q-value</h3><p>![[Pasted image 20240118130041.png]]</p>
<ul>
<li>Sensitivity&#x2F;TPR &#x3D; TP &#x2F; (TP + FN)对于“正”样本，被预测成“阳性”的比例是多少</li>
<li>Specificity&#x2F;TNR &#x3D; TN &#x2F; (TN + FP)对于“负”样本(m0)，被预测成“阴性”的比例是多少</li>
<li>False positive rate&#x2F;FPR &#x3D; FP &#x2F; (TN + FP)（通常的p-value）对于“负”样本，被预测成“阳性”的比例是多少</li>
<li>False discovery rate&#x2F;FDR &#x3D; FP &#x2F; (TP + FP)（误报率，大家更关心）预测为“阳性”的样本中，负样本的比例是多少</li>
<li>如果FDR&lt;α，我们就说这个多重检验的FDR被控制在了α水平<ul>
<li>FDR&lt;0.05：鉴定的n个显著差异表达基因中包含的错误个数&lt;5%<ul>
<li>对所有的P 值从小到大排序，记作P_i</li>
<li>Q-value &#x3D; P(k)*m&#x2F;k</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="QTL和WGAS"><a href="#QTL和WGAS" class="headerlink" title="QTL和WGAS"></a>QTL和WGAS</h2><ul>
<li>QTL<ul>
<li>QTL：代表染色体上影响数量性状的某个区段，区段内可能会有一个甚至多个影响数量性状的功能基因</li>
<li>QTL定位：指检查分子标记与     QTL间的连锁关系，并估算QTL的表型效应；其本质是利用功能基因与分子标记间的连锁与重组，实现对功能基因位置的定位</li>
<li>分离世代群体建立，遗传标记检测，表型测定，统计分析，候选基因鉴定</li>
<li>其本质是利用功能基因与分子标记间的连锁与重组，实现对功能基因位置的定位</li>
<li>定位的统计方法<ul>
<li>方差分析（F检验）、t检验、线性回归</li>
<li>线性模型的基础上，利用最大似然法对相邻标记构成的区间内任意一点可能存在的QTL进行似然比检验，进而获得其效应的极大似然估计</li>
<li>使用逐步回归，将其他与表型关联的QTL作为协变量控制背景遗传效应</li>
</ul>
</li>
</ul>
</li>
<li>GWAS<ul>
<li>连接遗传变异 (Genetic Variants, GVs)和表型 (phenotypes)的主要工具。</li>
<li>标记密度高，理论上可获得群体中所有的变异，并能利用历史上的重组，因而具有较高的定位精度。</li>
<li>具有丰富的变异，与人工构建的群体变异来源于两个或少数几个亲本相比，自然群体中的变异来自与几百上千乃至数十万的个体。</li>
<li>快速简便，无需构建群体耗时耗力的过程。<ul>
<li>自然群体资源的收集和鉴定（纯化）</li>
<li>获取目标性状的多次表型数据</li>
<li>表型数据分析（如：BLUP）</li>
<li>获取基因型数据</li>
<li>基因型补缺和过滤</li>
<li>遗传多样性、群体结构、亲缘关系、LD等分析</li>
<li>关联分析</li>
<li>候选基因筛选与挖掘</li>
<li>实验验证、分子机制解析</li>
</ul>
</li>
<li>重组事件的数目</li>
<li>标记的数目{要比重组事件多才能检测出重组}</li>
<li>群体大小{群体大了，重组事件多}</li>
<li>群体结构的影响{群体隔离和受选择都会降低重组率}</li>
<li>群体的类型{不同的群体，重组率差别很大；是否有杂合基因型也有影响}</li>
<li>表型的遗传率和测量误差的影响</li>
<li>模型的选择{线性模型&#x2F;混合模型}</li>
<li>位点之间是否存在复杂的互作。</li>
</ul>
</li>
</ul>
<h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><ul>
<li>线性回归![[Pasted image 20240118132318.png]]<ul>
<li>参数估计<ul>
<li>最小误差估计 最小二乘法</li>
<li>最大似然估计 最大似然估计</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>![[Pasted image 20240118132839.png]]</p>
<h3 id="差异分析、富集分析"><a href="#差异分析、富集分析" class="headerlink" title="差异分析、富集分析"></a>差异分析、富集分析</h3><ul>
<li>差异分析<ul>
<li>基于一些统计学模型，对不同样本处理下的基因表达差异进行分析，区分这种差异来源是源于处理效应，还是随机误差。</li>
<li>差异表达倍数 (Fold change)<ul>
<li>Avg(X) &#x2F; Avg(Y)![[Pasted image 20240118133131.png]]</li>
<li>正态性检验</li>
<li>威尔克逊秩和检验</li>
<li>差异表达线性模型</li>
<li>一般的t-检验</li>
<li>两组样品比较的方差估计</li>
</ul>
</li>
</ul>
</li>
<li>富集分析<ul>
<li>挖掘在数据库中与我们要研究的生物学问题具有显著相关性的基因功能类别<ul>
<li>过表达分析（检验差异表达基因是否与某个类别或者途径相关）</li>
<li>功能集打分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据处理通用算法"><a href="#数据处理通用算法" class="headerlink" title="数据处理通用算法"></a>数据处理通用算法</h2><h3 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h3><ul>
<li>缺失值估计<ul>
<li>找到在所有样品中与基因G的表达量最相关的J个基因</li>
<li>根据J个基因的表达量计算样品间距离，找到与样品A距离最小（最相似）、且基因G表达量有值的k个样品</li>
<li>计算k个样品中基因G的平均表达量，填补缺失值</li>
</ul>
</li>
</ul>
<h3 id="UPGMA"><a href="#UPGMA" class="headerlink" title="UPGMA"></a>UPGMA</h3><ul>
<li>将序列相似性最高（距离最近）的两条序列合并成一个分支，再计算新合并的分支与其它序列的平均距离；再按距离最近的两条序列（或合并分支）进行合并，直到所有序列都完成合并，最后获得有根树</li>
</ul>
<h3 id="其他聚类"><a href="#其他聚类" class="headerlink" title="其他聚类"></a>其他聚类</h3><ul>
<li>层次聚类<ul>
<li>计算该节点到其他所有节点的距离<ul>
<li>Furthest-Neighbour：max</li>
<li>Nearest-Neighbour：min</li>
<li>UPGMA：avg</li>
</ul>
</li>
</ul>
</li>
<li>K-means（k&#x3D;7或者层次聚类)<ul>
<li>随机找k个质心</li>
<li>进行分类</li>
<li>重复上述步骤直到稳定</li>
</ul>
</li>
<li>K-mediod<ul>
<li>从散点图中选择k个数据点作为聚类中心的起点。</li>
<li>计算它们与散点图中所有点的距离，将每个点分类到最接近中心的聚类中。</li>
<li>在每个群集中选择一个新点，以使该群集中所有点与新点的距离之和最小。</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="median-polish"><a href="#median-polish" class="headerlink" title="median polish"></a>median polish</h3><ul>
<li>每个芯片归一化到它的中位数</li>
<li>每个基因归一化到它的中位数</li>
<li>重复，直到中位数收敛</li>
<li>最多5次迭代，以防止无限循环。</li>
</ul>
<h3 id="Quantile-normalization"><a href="#Quantile-normalization" class="headerlink" title="Quantile normalization"></a>Quantile normalization</h3><ul>
<li>对所有芯片的数据进行均一化，使其分布相同<ul>
<li>根据列排序；</li>
<li>计算每行的平均数；</li>
<li>按照原来列的排序重新排列。</li>
</ul>
</li>
</ul>
<h3 id="Moderated-t-test-Pasted-image-20240118140230-png"><a href="#Moderated-t-test-Pasted-image-20240118140230-png" class="headerlink" title="Moderated t-test![[Pasted image 20240118140230.png]]"></a>Moderated t-test![[Pasted image 20240118140230.png]]</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://psrpsr23.github.io/blog/2024/04/28/note/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8E%9F%E7%90%86/%E6%80%BB%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86/" data-id="clvj9cw5n000nqkhtazb4fu6y" data-title="" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2024/04/28/note/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8E%9F%E7%90%86/%E6%80%BB%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/blog/2024/04/28/note/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8E%9F%E7%90%86/%E5%9F%BA%E5%9B%A0%E8%A1%A8%E8%BE%BE%E8%B0%B1%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/04/">四月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2024/04/28/%E5%BA%8F%E5%88%97%E6%A8%A1%E6%8B%9F%E8%AE%BA%E6%96%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2024/04/28/note/%E8%BD%AC%E8%BF%90%E8%9B%8B%E7%99%BD%E7%A7%91%E7%A0%94/%E5%BA%8F%E5%88%97%E6%A8%A1%E6%8B%9F%E8%AE%BA%E6%96%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2024/04/28/note/%E8%BD%AC%E8%BF%90%E8%9B%8B%E7%99%BD%E7%A7%91%E7%A0%94/ZeroBind/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2024/04/28/note/%E7%8E%89%E7%B1%B3/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2024/04/28/note/%E7%8E%89%E7%B1%B3/%E5%88%86%E5%B8%83%E5%9B%BE/%E5%90%84motif%E5%88%86%E5%B8%83%E5%9B%BE/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 彭澍荣# 博客的作者<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/blog/js/script.js"></script>





  </div>
</body>
</html>